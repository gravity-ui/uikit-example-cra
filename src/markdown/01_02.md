# React Hooks

**Хук** - это функция, которая вызывается в теле функционального компонента и придает ему дополнительную функциональность
Как и любая функция, хук может принимать аргументы и возвращать значение.

Реакт под капотом регистрирует все хуки, потому они должны находиться строго до любых условий (*if, switch*), и все хуки должны начинаться с префикса *use*.

[Документация...](https://react.dev/reference/react/hooks)

## **useState** 

`const [state, setState] = useState(initialValue);`

- добавляет локальное состояние в функциональные компоненты

- в качестве начального состояния можно передавать функцию, которая вернет начальное состояние *useState(getStoredState)*

- это **асинхронный** хук, он не меняет состояние сразу, а будет ждать завершения цикла компонента, повторного рендеринга, и только затем обновит состояние. Потому любые счетчики *setState(prevCount => prevCount + 1)*, переключатели *setState(prevValue => !prevValue)*  должны опираться на предыдущее состояние, иначе это может привести к непредсказуемым ошибкам

- cостояние может быть чем угодно: строкой, числом, массивом и т.д. и с ним можно работать как с любой другой переменной, но изменять только с помощью функции изменения состояния

- хук useState обновляет компонент только если новое состояние не равно предыдущему. Проверка осуществляется по строгому равенству *prevState === newState*

[Подробнее...](https://habr.com/ru/companies/otus/articles/667706/)

## **useEffect** 

*function useEffect(effect: EffectCallback, deps?: DependencyList): void;*

*type DependencyList = ReadonlyArray<any>;*

*type EffectCallback = () => (void | (() => void | undefined));*

- позволяет выполнять побочные эффекты в функциональных компонентах, например, выполнение кода после рендеринга компонента, подписка на внешние данные

- Принимает 2 аргумента, последний не обязателен:

  1. *effect*-это функция, внутри которой происходит работа с обновленными данными. Эта функция может вернуть другую функцию (*cleanup*), внутри которой происходит работа с данными до обновления.

  2. Массив зависимостей.

-  Когда любое значение из массива зависимостей изменится, вызовется функция *effect*

-  Также *effect* будет вызван при монтировании компонента.

-  функция *cleanup* будет вызвана при размонтировании компонента, либо до обновления любого значения из массива зависимостей

-  *useEffect* без массива зависимостей будет вызван каждый раз при обновлении компонента

-  этот хук **асинхронный** и будет вызван после того, как браузер отрисует компоненты


```
// Монтирование, размонтирование и обновление

useEffect(() => {
  // это effect
	// этот код будет выполнен при монтировании компонента (componentDidMount)
  // а также после обновления любого элемента из массива зависимостей (componentDidUpdate)

  return () => {
    // это cleanup
  	// этот код будет выполнен при размонтировании компонента (componentWillUnmount)
    // а также до обновления любого элемента из массива зависимостей (componentWillUpdate)
  }
}, [dep1, dep2]);
```
[Подробнее...](https://habr.com/ru/companies/otus/articles/668700/)



## **useLayoutEffect**

- подобен *useEffect*, но срабатывает **синхронно** когда компоненты уже находятся на *virtual dom* (в памяти и можно прочитать/установить различные свойств), но еще не были отрисованы браузером

- позволяет вычислять параметры компонентов и изменять их до того, как браузер отрендерит их. Это предотвращает "мерцание" компонентов и улучшает производительность, потому что рендеринг происходит только 1 раз


## **useContext** 

- позволяет получить доступ к контексту приложения

## **useReducer**

 - предоставляет способ управления сложным локальным состоянием компонента через паттерн управления состоянием *Reducer*

## **useRef**

 - позволяет создавать и управлять ссылками на DOM-элементы и другие объекты

 - это синхронный хук, который немедленно обновляет состояние и сохраняет его значение на протяжении всего жизненного цикла компонента
 
 - он не запускает повторный рендер компонента

## **useMemo**

 - оптимизирует производительность компонентов, предотвращая повторные вычисления

## **useCalback**

 - оптимизирует производительность компонентов, предотвращая ненужные перерисовки компонентов
    - использование useCallback выгодно только в случае передачи функции как props
  
  ```
  const Cars = ({ cars }) => {
    const onCarClick = useCallback((car) => {
      console.log(car.model);
    }, []);

    return cars.map((car) => {
      return (
        <Car key={car.id} car={car} onCarClick={onCarClick} />
      )
    });
  }
  ```
  Таким образом все компоненты Car не будут рендериться лишний раз, т.к. ссылка на функцию останется прежней.

  ```
  const Car = ({ car, onCarClick }) => {
   const onClick = () => onCarClick(car);
  
    return (
      <button onClick={onClick}>{car.model}</button>
    )
  }
  
  ```
  А вот здесь уже нет никакой пользы оборачивать метод в useCallback

  [Подробнее...](https://habr.com/ru/articles/529950/)


## **useEffectOnce** 

- позволяет выполнить эффект только один раз после первого рендеринга компонента


## **useDebugValue** 

- предоставляет дополнительную отладочную информацию для кастомных хуков

## **useHistory**, **useLocation** 

- позволяют взаимодействовать с историей браузера и текущим URL внутри компонента

## **useParams** 

- извлекает параметры из URL при использовании маршрутизации

## **useForm** 

- помогает управлять состоянием форм и их валидацией

## **useFetch** 

- предоставляет удобный способ выполнения HTTP-запросов

## **useWindowSize** 

- отcлеживает изменения размеров окна браузера

## **useId**

- возвращает уникальный id, он сохраняется на протяжении всей жизни компонента

## **useTransition**

## **useDeferredValue**

## **useSyncExternalStore**

- предназначен для использования библиотеками, а не кодом приложения

## **useInsertionEffect**

- предназначен для использования библиотеками, а не кодом приложения

