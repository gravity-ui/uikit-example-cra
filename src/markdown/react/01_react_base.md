# Базовые понятия

## JavaScript ##

- это динамический язык программирования, который используется для создания интерактивных веб-страниц.

- JavaScript обычно используется как встраиваемый язык для программного доступа к объектам приложений

- мультипарадигменный язык программирования. Поддерживает объектно-ориентированный, императивный и функциональный стили. [Википедия...](https://ru.wikipedia.org/wiki/JavaScript)


Его разработал Брендан Эйх (Brendan Eich, сооснователь проекта Mozilla, Mozilla Foundation и Mozilla Corporation) в компании Netscape в 1995 году как объектный скриптовый язык с открытым стандартом

По инициативе компании Netscape в 1996-1997 гг была проведена стандартизация языка ассоциацией ECMA. Стандартизированная версия имеет название ECMAScript, описывается стандартом ECMA-262 [Википедия...](https://ru.wikipedia.org/wiki/ECMAScript)

## JSX

\- это синтаксическое расширение *JS*, позволяющее писать *HTML*-разметку внутри *JS*

- в **JSX** можно использовать:
  -  тэги *HTML*
  -  вложенные тэги
  -  интерполяции (вставки любых корректных *JavaScript*-выражений внутри фигурных скобок)

- если тег пуст, то его можно сразу же закрыть с помощью />

- **JSX** можно:
  -  использовать внутри инструкций if и циклов for
  -  присваивать переменным
  -  передавать функции в качестве аргумента и возвращать из функции

- **JSX** предотвращает атаки, основанные на инъекции кода (*XSS*), т.к. *React DOM* экранирует все значения, включённые в JSX перед тем как отрендерить их

```jsx
const element = (
  <h1 className="greeting">
    Привет, мир!
  </h1>
);
```

- после компиляции JSX превращается в объект примерно такого вида:


```jsx
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Привет, мир!'
  }
}
```


**особености JSX**: 
- атрибут *style* в качестве значения принимает объект javascript
- в наименованиях используется *camel-case*, т.о. *font-family* заменяется на *fontFamily*, *tabindex* - на *tabIndex*
- *class* заменяется на *className*, *for* заменяется на *htmlFor*, 


```jsx
const element = (
  <span className={userClassName} style={{color:"red", fontFamily:"Verdana"}}>
    Привет, {user}!
  <span>
)
```


## React ##

\- это *JavaScript*-библиотека с открытым исходным кодом для разработки пользовательских интерфейсов [Википедия...](https://ru.wikipedia.org/wiki/React)

- чаще всего используется для создания одностраничных приложений (*SPA - single page application*), где требуется быстрый и интерактивный пользовательский интерфейс. 

- одна из ключевых особенностей *React* - **компонентная архитектура**: пользовательский интерфейс разделен на несколько компонентов, каждый из которых отвечает за рендеринг части пользовательского интерфейса

- в **React** используется однонаправленная передача данных: cвойства передаются от родительских компонентов к дочерним. Компоненты получают свойства как множество неизменяемых значений, поэтому компонент не может напрямую изменять свойства, но может вызывать изменения через callback-функции. Такой механизм называют *свойства вниз, события наверх*

[Почему React не реактивен?](https://dev.to/balaevarif/pochiemu-react-nie-rieaktivien-40ig)

## React-компоненты

**Компонент**- независимая и переиспользуемая часть интерфейса, может содержать в себе как структуру (HTML-элементы), так и логику.

- компонетны могут ссылаться на другие компоненты
- имена компонентов должны начинаться с заглавной буквы


**Классовый компонент** - класс, который наследуется от *React.Component*, может содержать состояние (*state*), методы жизненного цикла и метод *render*, возвращающий *jsx*-разметку

- \+ прямой доступ к методам жизненного цикла 
- \+ можно использовать классовые свойства для хранения данных без необходимости использования *this.setState*
- \+? есть наследование 
- \- *State* может быть только один
- \- надо не забывать писать *this* 
- \- в целом больше кода


**Функциональный компонент** - функция, принимающая входные данные (*props*) и возвращающая *JSX*, определяющий структуру компонента.
- \+ компактный код, проще для понимания
- \+ код более декларативный и легче читается
- \+ их проще тестировать (не требуют создания экземпляров класса)
- \+ можно делать много *State*-ов
- \+ можно пользоваться хуками, в т.ч. самописными 
- \+ проект, полностью написанный на хуках, имеет менее глубокое дерево компонентов
- \- весь код внутри одной функции

[Еще немного про классовые и функциональные компоненты...](https://habr.com/ru/companies/ruvds/articles/444348/)



- **Презентационный компонент** (тупой компонент, dumb component)
используется для получения данных и их отображения на странице 

``` js
import React from 'react';

function Button(props) {
  return <button>{props.label}</button>;
}
```
 
- **Компонент-контейнер** заботится о том, как все работает. 
  
  - может содержать логику для выборки данных, обработки пользовательского ввода и выполнения других задач
  
  - знает о состоянии и действиях приложения
  
  - передает данные и обратные вызовы презентационным компонентам через пропсы

```js
import React, { Component } from 'react';
import Button from './Button';

class Form extends Component {
 state = {
   name: '',
 };

 handleChange = (event) => {
   this.setState({ name: event.target.value });
 };

 handleSubmit = (event) => {
   event.preventDefault();
   // отправка формы
 };

 render() {
   return (
     <form onSubmit={this.handleSubmit}>
       <label>
         Name:
         <input type="text" value={this.state.name} onChange={this.handleChange} />
       </label>
       <Button label="Submit" />
     </form>
   );
 }
}
```




- **Управляемый компонент** получает все свои данные в качестве реквизита и передает изменения своему родительскому компоненту через обратные вызовы
 
- **Неуправляемый компонент** сам управляет своим собственным состоянием внутри себя
 

## Чистая функция

\- это функция, которая не меняет свои входные данные и предсказуемо возвращает один и тот же результат для одинаковых аргументов

```js
function sum(a, b) {
  return a + b;
}
```

## Props (сокр. от "propetries") 
 
 - объект *props* предоставляет интерфейс для передачи данных от родительского компонента к дочернему и позволяет динамически настраивать компоненты
 - пропсы передаются компоненту в виде атрибутов и становятся доступными внутри компонента как свойства
 - являются неизменяемыми (*React*-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам)
 - им можно задавать значения по умолчанию

## State (состояние)

- это специальный объект внутри компонента для хранения и отслеживания изменяющихся данных

- *state* доступен только для самого компонента и скрыт от других

- он позволяет компоненту запоминать данные и перерисовывать себя, когда эти данные меняются

- каждый компонент имеет собственный *state*, что позволяет изолировать данные и логику между компонентами

- *state* инициализируется в конструкторе компонента (в классовых компонентах) или с помощью хука *UseState* (в функциональных)

- *state* изменяется методом *setState* (в классовых компонентах) или функцией, возвращаемой *UseState* (в функциональных)

- изменения стейта происходят асинхронно, React может объединять несколько обновлений стейта для оптимизации производительности

- рекомендуется не изменять состояние напрямую, а создавать новый объект *state* с обновленными данными, что упрощает отслеживание изменений

- *state* может быть передан дочерним компонентам через пропсы

## Жизненный цикл компонента

- монтирование (*mounting*) - первоначальный рендеринг компонента в *DOM*

- обновление (*updating*) - компонент повторно визуализируетсят при изменении его свойств или состояний

- размонтирование (*unmounting*) - удаление компонента из *DOM*

## Методы жизненного цикла в классовых компонентах

- ***монтирование***

  1. **constructor(props)** начальная инициализация компонента 

  2. **getDerivedStateFromProps(nextProps,prevState)** вызывается непосредственно перед методом рендеринга
      - nextProps \— объект, представляющий новые реквизиты, которые получает компонент
      - prevState \— объект, представляющий текущее состояние компонента
    - метод должен возвращать объект для обновления состояния или значение null, чтобы указать, что новые свойства не требуют каких-либо обновлений состояния
    - это статический метод, а это значит, что у него нет доступа к экземпляру компонента, поэтому нельзя использовать this внутри getDerivedStateFromProps
    - он не запускает повторную отрисовку, но позволяет обновлять состояние на основе изменений в реквизитах
    - обновленное состояние будет использоваться при следующем рендеринге
    [Подробнее...](https://www.dhiwise.com/post/best-practices-for-using-getderivedstatefromprops-in-your-react-applications)

  3. **render()** рендеринг компонента

  4. **componentDidMount**  вызывается после рендеринга компонента, здесь можно выполнять настройки, для которых необходим DOM, отправлять запросы к удаленным ресурам, настроить прослушиватели событий и т. д.

- ***обновление***

  1. **getDerivedStateFromProps(*nextProps,prevState*)**

  2. **shouldComponentUpdate(*nextProps, nextState*)** вызывается каждый раз при обновлении объекта props или state
    - *nextProps, nextState* \- новые объекты
    - метод должен возвращать логическое значение, и на его основе будет определяться, будет ли компонент перерисован или нет
  
  3. **render()** рендеринг компонента, если на предыдущем шаге было получено *true*  

  4. **getSnapshotBeforeUpdate(*prevProps, prevState*)** позволяет компоненту получить информацию из DOM перед возможным обновлением. Возвращает в качестве значения какой-то отдельный аспект, который передается в качестве третьего параметра в метод *componentDidUpdate()*. Если нечего возвращать, то возвращается значение null

  5. **componentDidUpdate(*prevProps, prevState, snapshot*)** вызывается сразу после обновления компонента (если *shouldComponentUpdate* возвращает true)
    - *prevProps, prevState* - старые значения объектов props и state
    - *snapshot* \- значение, которое вернул метод *getSnapshotBeforeUpdate*
    - метод обычно используется для обновления DOM в ответ на изменение пропсов или состояния

- ***размонтирование*** 
    -  **componentWillUnmount()** вызывается перед размонтированием, позволяет отменить любые исходящие сетевые запросы или удалить все прослушиватели событий, связанные с компонентом

## Компонент высшего порядка (Higher Order Component, HOC)

- это функция-обертка, которая принимает компонент и возвращает новый компонент с дополнительной функциональностью

- *HOC* не должен менять поведение и оригинальное предназначение оборачиваемого компонента

[Подробнее...](https://ru.legacy.reactjs.org/docs/higher-order-components.html)

## TypeScript

- это язык, предоставляющий статическую типизацию поверх JS


