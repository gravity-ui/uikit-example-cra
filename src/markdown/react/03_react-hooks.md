# Хуки React

**Хук** - это функция, которая вызывается в теле функционального компонента и придает ему дополнительную функциональность
Как и любая функция, хук может принимать аргументы и возвращать значение.

Реакт под капотом регистрирует все хуки, потому они должны находиться строго на верхнем уровне компонента, вне любых блоков условий или циклов, и все хуки должны начинаться с префикса ***use***.

[Документация...](https://react.dev/reference/react/hooks)

## useState

`const [state, setState] = useState(initialValue);`

- добавляет локальное состояние в функциональные компоненты

- в качестве начального состояния можно передавать функцию, которая вернет начальное состояние ***useState(getStoredState)***

- это **асинхронный** хук, он не меняет состояние сразу, а будет ждать завершения цикла компонента, повторного рендеринга, и только затем обновит состояние. Потому любые счетчики ***setState(prevCount => prevCount + 1)***, переключатели ***setState(prevValue => !prevValue)***  должны опираться на предыдущее состояние, иначе это может привести к непредсказуемым ошибкам

- cостояние может быть чем угодно: строкой, числом, массивом и т.д. и с ним можно работать как с любой другой переменной, но изменять только с помощью функции изменения состояния

- хук useState обновляет компонент только если новое состояние не равно предыдущему. Проверка осуществляется по строгому равенству ***prevState === newState***

[Подробнее...](https://habr.com/ru/companies/otus/articles/667706/)

- значения состояния остается "фиксированными" в обработчиках событий одного рендера, даже если код обработчика события асинхронный

- *React* хранит состояние *вне компонента*, как на полке

- когда вызывается **useState**, React отдает снимок состояния для данного рендера

- каждый рендер (и функции внутри него) всегда будет "видеть" снимок состояния, который React передал этому рендеру

- переменные и обработчики событий не "переживают" повторных рендеров, каждый рендер имеет свои собственные обработчики событий

[Состояние как моментальный снимок...](https://reactdev.ru/learn/state-as-a-snapshot/#_4)

[Очередь обновлений состояния...](https://reactdev.ru/learn/queueing-a-series-of-state-updates/#_4)

- если в *State* хранится объект *obj*, его нельзя мутировать, необходимо каждый раз создавать новую копию объекта:
  `setState({...obj, something:'newValue'})` 

- для упрощения работы с объектами в *State* можно использовать **Immer**:
  
  `npm install use-immer`

```jsx
import { useImmer } from 'use-immer';

export default function Form() {
    const [person, updatePerson] = useImmer({
        name: 'Niki de Saint Phalle',
        artwork: {
            title: 'Blue Nana',
            city: 'Hamburg',
        },
    });

    function handleNameChange(e) {
        updatePerson((draft) => {
            draft.name = e.target.value;
        });
    }
    ...

 ```

[Обновление объектов в состоянии...](https://reactdev.ru/learn/updating-objects-in-state/#_4)

- аналогично для массивов,  их нельзя мутировать, надо создавать новый массив или делать копию исходного

[Обновление массивов в состоянии...](https://reactdev.ru/learn/updating-arrays-in-state/#_2)

## useEffect

***function useEffect(effect: EffectCallback, deps?: DependencyList): void;***

***type DependencyList = ReadonlyArray<any>;***

***type EffectCallback = () => (void | (() => void | undefined));***

- позволяет выполнять побочные эффекты в функциональных компонентах, например, выполнение кода после рендеринга компонента, подписка на внешние данные

- Принимает 2 аргумента, последний не обязателен:

  1. ***effect***-это функция, внутри которой происходит работа с обновленными данными. Эта функция может вернуть другую функцию (***cleanup***), внутри которой происходит работа с данными до обновления.

  2. Массив зависимостей.

-  Когда любое значение из массива зависимостей изменится, вызовется функция *effect*

-  Также ***effect*** будет вызван при монтировании компонента.

-  функция ***cleanup*** будет вызвана при размонтировании компонента, либо до обновления любого значения из массива зависимостей

-  ***useEffect*** без массива зависимостей будет вызван каждый раз при обновлении компонента

-  этот хук **асинхронный** и будет вызван после того, как браузер отрисует компоненты

```js
// Монтирование, размонтирование и обновление
useEffect(() => {
  // это effect
  // этот код будет выполнен при монтировании компонента (componentDidMount)
  // а также после обновления любого элемента из массива зависимостей (componentDidUpdate)
  return () => {
  // это cleanup
	// этот код будет выполнен при размонтировании компонента (componentWillUnmount)
  // а также до обновления любого элемента из массива зависимостей (componentWillUpdate)
  }
}, [dep1, dep2]);
```
-  Когда включен *Strict Mode* (cтрогий режим), *React* перемонтирует каждый компонент один раз после монтирования (состояние и DOM сохраняются). Если эффект ломается из-за повторного монтирования,  необходимо реализовать функцию очистки. *React* будет вызывать функцию очистки перед следующим запуском эффекта и во время повторного монтирования.

- Эффекты необходимо использовать только для кода, который должен выполняться по причине отображения компонента пользователю

[Подробнее...](https://habr.com/ru/companies/otus/articles/668700/)

[Синхронизация с эффектами...](https://reactdev.ru/learn/synchronizing-with-effects/#4)

## useLayoutEffect

- цель **useLayoutEffect** - позволить вашему компоненту использовать информацию о макете для рендеринга

- подобен ***useEffect***, но срабатывает **синхронно** когда компоненты уже находятся на ***virtual dom*** (в памяти и можно прочитать/установить различные свойств), но еще не были отрисованы браузером

- позволяет вычислять параметры компонентов и изменять их до того, как браузер отрендерит их. Это предотвращает "мерцание" компонентов и улучшает производительность, потому что рендеринг происходит только 1 раз

- код внутри useLayoutEffect и все запланированные обновления состояния блокируют браузер от перерисовки экрана, что может замедлять работу приложения

[Подробнее...](https://reactdev.ru/reference/useLayoutEffect/#2-useeffect)

## useInsertionEffect

- это версия useEffect, которая срабатывает перед любыми мутациями DOM

- его основной вариант использования — вставка глобальных узлов DOM, таких как *<style>* или SVG *<defs>*

- он не имеет доступа к ссылкам узлов DOM,т.к.к моменту запуска useInsertionEffect, ссылки еще не прикреплены, и DOM еще не обновлен


``` js
useInsertionEffect(setup, dependencies?)

```
[Подробнее..](https://reactdev.ru/reference/useInsertionEffect/)


## useContext

- позволяет получить доступ к контексту приложения

- контекст позволяет компоненту предоставлять некоторую информацию всему дереву под ним

- чтобы передать контекст необходимо:

    1. Создать и экспортировать его с помощью `export const MyContext = createContext(defaultValue)`
    2. Передать  его в хук `useContext(MyContext)`, чтобы прочитать его в любом дочернем компоненте, независимо от его глубины.
    3. Завернуть дочерние компоненты в `<MyContext.Provider value={...}>`, чтобы предоставить его от родителя.

- контекст проходит через любые компоненты в середине

- контекст позволяет писать компоненты, которые "адаптируются к своему окружению".

[Подробнее...](https://reactdev.ru/learn/passing-data-deeply-with-context/#_6)

## useReducer

 - предоставляет способ управления сложным локальным состоянием компонента через паттерн управления состоянием ***Reducer***

```js
const [state, dispatch] = useReducer(
    yourReducer,
    initialState
);

```
- обработчики событий компонента (onClick,onChange и т.п.) должны теперь только извещать редуктор о том, какое действие совершил пользователь:

```js
function handleOnClick(anyValue) {
  dispatch({
    //// action object, specific to component:
    type: 'what_happened',
    // other fields go here
    anyVar: anyValue
  });
};
```
- *action object* (объект действия) должен содержать минимальную информацию о том, что произошло

- он может иметь любую форму, принято задавать ему строку type, описывающую произошедшее, и передавать любую дополнительную информацию в других полях

- каждый объект действия должен описывать только одно взаимодействие пользователя, даже если оно приводит к нескольким изменениям данных

- **Reducer** (редуктор) принимает состояние на данный момент и действие, а возвращает следующее состояние


```jsx
function yourReducer(state, action) {
  switch (action.type) {
    case 'action1': {
      return state1;
    }
      case 'action2': {
        return state2;
    } 
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
 ```
 
- редукторы работают во время рендеринга! (Действия ставятся в очередь до следующего рендера.) Это означает, что редукторы должны быть чистыми - одинаковые входы всегда приводят к одинаковому выходу. Они не должны посылать запросы, планировать таймауты или выполнять какие-либо побочные эффекты (операции, которые влияют на вещи за пределами компонента). Они должны обновлять объекты и массивы без мутаций

- для написания реукторов в мутирующем стиле можно использовать библиотеку *Immer*

[Подробнее...](https://reactdev.ru/learn/extracting-state-logic-into-a-reducer/#1)



## useRef

- позволяет создавать и управлять ссылками на DOM-элементы и другие объекты (идентификаторы таймаута, счетчики и пр.), 

- это синхронный хук, который немедленно обновляет состояние и сохраняет его значение на протяжении всего жизненного цикла компонента
 
- он не запускает повторный рендер компонента

- хук возвращает объект с единственным свойством *current*, содержащим текущее значение ссылки

- например, нажатие на кнопку фокусирует ввод, используя ссылку:

```jsx
import { useRef } from 'react';

export default function Form() {
    const inputRef = useRef(null);

    function handleClick() {
        inputRef.current.focus();
    }

    return (
        <>
            <input ref={inputRef} />
            <button onClick={handleClick}>
                Focus the input
            </button>
        </>
    );
}

```


## useMemo

-  позволяет кэшировать результат вычисления между повторными рендерингами, оптимизирует производительность компонентов, предотвращая повторные вычисления

```js
const cachedValue = useMemo(calculateValue, dependencies);

```

  -  **calculateValue**: функция, вычисляющая значение, которое необходимо кэшировать. 
      -  должна быть чистой, 
      -  не принимет аргументов
      -  может возвращать значение любого типа.
      -  *React* будет вызывать эту функцию во время начального рендера. 
      -  При последующих рендерах *React* будет возвращать то же значение, если зависимости не изменились с момента последнего рендера. В противном случае он вызовет **calculateValue**, вернет результат и сохранит его, чтобы можно было использовать в дальнейшем.

  -  **dependencie** (зависимости): список всех реактивных значений, на которые ссылается код *calculateValue*, может включать:
    -  пропсы
    -  состояние
    -  переменные и функции, объявленные непосредственно в теле компонента

-  в режиме *Strict Mode*  при разработке *React* будет вызывать функцию *calculateValue* дважды. Если функция вычисления чиста (как и должно быть), это не должно повлиять на логику работы программы. Результат одного из вызовов будет проигнорирован.

[Подробнее...](https://reactdev.ru/reference/useMemo/#_6)


## useCalback

 - оптимизирует производительность компонентов, предотвращая ненужные перерисовки компонентов

 - использование useCallback выгодно только в случае передачи функции как props


```js
const Cars = ({ cars }) => {
  const onCarClick = useCallback((car) => {
    console.log(car.model);
  }, []);
  return cars.map((car) => {
    return (
      <Car key={car.id} car={car} onCarClick={onCarClick} />
    )
  });
}
```

  Таким образом все компоненты Car не будут рендериться лишний раз, т.к. ссылка на функцию останется прежней.


```js
const Car = ({ car, onCarClick }) => {
 const onClick = () => onCarClick(car);

  return (
    <button onClick={onClick}>{car.model}</button>
  )
}
```

  А вот здесь уже нет никакой пользы оборачивать метод в useCallback

  [Подробнее...](https://habr.com/ru/articles/529950/)


## useDebugValue

`useDebugValue(value, format?)`

- предоставляет дополнительную отладочную информацию для кастомных хуков

  - **value**: значение, которое будет отображаться в *React DevTools*

  - опционально **format**: функция форматирования. При осмотре компонента *React DevTools* вызовет функцию форматирования с *value* в качестве аргумента, а затем отобразит возвращенное форматированное значение.Если не указать функцию форматирования, будет отображено исходное *value*.


```js
useDebugValue(date, (date) => date.toDateString());
```

[Подробнее...](https://reactdev.ru/reference/useDebugValue/)




## useForm

- помогает управлять состоянием форм и их валидацией

## useFetch

- предоставляет удобный способ выполнения HTTP-запросов

## useWindowSize

- отcлеживает изменения размеров окна браузера

## useId

- возвращает уникальный id, он сохраняется на протяжении всей жизни компонента

```jsx
import { useId } from 'react';

function PasswordField() {
    const passwordHintId = useId();
    return (
        <>
            <label>
                Password:
                <input
                    type="password"
                    aria-describedby={passwordHintId}
                />
            </label>
            <p id={passwordHintId}>
                The password should contain at least 18
                characters
            </p>
        </>
    );
}
```

- компонент может отображаться на странице более одного раза, но идентификаторы при этом будут уникальными

[Подробнее...](https://reactdev.ru/reference/useId/#_6)


## useTransition

` const [isPending, startTransition] = useTransition();`

-  позволяет обновлять состояние без блокировки пользовательского интерфейса

  - флаг isPending сообщает, есть ли ожидающий переход

  - функция startTransition позволяет пометить обновление состояния как переход

- Функция, которая передается в startTransition, должна быть синхронной.

- Переходы позволяют сохранить отзывчивость обновлений пользовательского интерфейса даже на медленных устройствах (пользовательский ввод будет обработан не дожидаясь завершения повторного рендеринга)

- Переходы предотвращают нежелательные индикаторы загрузки, что позволяет пользователю избежать резких скачков при навигации

[Подробнее...](https://reactdev.ru/reference/useTransition/#starttransition_1)


## useDeferredValue

`useDeferredValue(value)`

- используется для показа устаревшего содержимого во время загрузки свежего

- *React* сначала выполнит рендеринг без обновления отложенного значения, а затем попытается выполнить рендеринг с вновь полученным значением в фоновом режиме

- *useDeferredValue* позволяет установить приоритет обновления ввода (которое должно быть быстрым) над обновлением списка результатов (которое может быть более медленным)



## useSyncExternalStore

-  позволяет подписаться на внешнее хранилище

```js
const snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)
```
  -  функция **subscribe** должна подписываться на стор и возвращать функцию, которая отписывается.
     Она принимает один аргумент - *callback*. Когда стор изменяется,вызывается предоставленный *callback*. Это приведет к повторному отображению компонента
  
  -  функция **getSnapshot** должна считывать моментальный снимок данных из хранилища.Пока хранилище не изменилось, повторные вызовы *getSnapshot* должны возвращать одно и то же значение. Если стор изменился, а возвращаемое значение отличается, *React* перерисовывает компонент.

  -  опциональная *getServerSnapshot*: функция, возвращающая начальный снимок данных в хранилище. Он будет использоваться только при рендеринге сервера и при гидратации рендеримого сервером контента на клиенте. Серверный снимок должен быть одинаковым для клиента и сервера, и обычно сериализуется и передается от сервера к клиенту. Если опустить этот аргумент, рендеринг компонента на сервере приведет к ошибке.


-  хук *useSyncExternalStore* предназначен для использования библиотеками, а не кодом приложения

[Подробнее...](https://reactdev.ru/reference/useSyncExternalStore/#_4)

