# React Hooks

**Хук** - это функция, которая вызывается в теле функционального компонента и придает ему дополнительную функциональность
Как и любая функция, хук может принимать аргументы и возвращать значение.

Реакт под капотом регистрирует все хуки, потому они должны находиться строго на верхнем уровне компонента, вне любых блоков условий или циклов, и все хуки должны начинаться с префикса ***use***.

[Документация...](https://react.dev/reference/react/hooks)

## useState

`const [state, setState] = useState(initialValue);`

- добавляет локальное состояние в функциональные компоненты

- в качестве начального состояния можно передавать функцию, которая вернет начальное состояние ***useState(getStoredState)***

- это **асинхронный** хук, он не меняет состояние сразу, а будет ждать завершения цикла компонента, повторного рендеринга, и только затем обновит состояние. Потому любые счетчики ***setState(prevCount => prevCount + 1)***, переключатели ***setState(prevValue => !prevValue)***  должны опираться на предыдущее состояние, иначе это может привести к непредсказуемым ошибкам

- cостояние может быть чем угодно: строкой, числом, массивом и т.д. и с ним можно работать как с любой другой переменной, но изменять только с помощью функции изменения состояния

- хук useState обновляет компонент только если новое состояние не равно предыдущему. Проверка осуществляется по строгому равенству ***prevState === newState***

[Подробнее...](https://habr.com/ru/companies/otus/articles/667706/)

- значения состояния остается "фиксированными" в обработчиках событий одного рендера, даже если код обработчика события асинхронный

- *React* хранит состояние *вне компонента*, как на полке

- когда вызывается **useState**, React отдает снимок состояния для данного рендера

- каждый рендер (и функции внутри него) всегда будет "видеть" снимок состояния, который React передал этому рендеру

- переменные и обработчики событий не "переживают" повторных рендеров, каждый рендер имеет свои собственные обработчики событий

[Состояние как моментальный снимок...](https://reactdev.ru/learn/state-as-a-snapshot/#_4)

[Очередь обновлений состояния...](https://reactdev.ru/learn/queueing-a-series-of-state-updates/#_4)

- если в *State* хранится объект *obj*, его нельзя мутировать, необходимо каждый раз создавать новую копию объекта:
  `setState({...obj, something:'newValue'})` 

- для упрощения работы с объектами в *State* можно использовать **Immer**:
  
  `npm install use-immer`

```jsx
import { useImmer } from 'use-immer';

export default function Form() {
    const [person, updatePerson] = useImmer({
        name: 'Niki de Saint Phalle',
        artwork: {
            title: 'Blue Nana',
            city: 'Hamburg',
        },
    });

    function handleNameChange(e) {
        updatePerson((draft) => {
            draft.name = e.target.value;
        });
    }
    ...

 ```

[Обновление объектов в состоянии...](https://reactdev.ru/learn/updating-objects-in-state/#_4)

- аналогично для массивов,  их нельзя мутировать, надо создавать новый массив или делать копию исходного

[Обновление массивов в состоянии...](https://reactdev.ru/learn/updating-arrays-in-state/#_2)

## useEffect

***function useEffect(effect: EffectCallback, deps?: DependencyList): void;***

***type DependencyList = ReadonlyArray<any>;***

***type EffectCallback = () => (void | (() => void | undefined));***

- позволяет выполнять побочные эффекты в функциональных компонентах, например, выполнение кода после рендеринга компонента, подписка на внешние данные

- Принимает 2 аргумента, последний не обязателен:

  1. ***effect***-это функция, внутри которой происходит работа с обновленными данными. Эта функция может вернуть другую функцию (***cleanup***), внутри которой происходит работа с данными до обновления.

  2. Массив зависимостей.

-  Когда любое значение из массива зависимостей изменится, вызовется функция *effect*

-  Также ***effect*** будет вызван при монтировании компонента.

-  функция ***cleanup*** будет вызвана при размонтировании компонента, либо до обновления любого значения из массива зависимостей

-  ***useEffect*** без массива зависимостей будет вызван каждый раз при обновлении компонента

-  этот хук **асинхронный** и будет вызван после того, как браузер отрисует компоненты

```js
// Монтирование, размонтирование и обновление
useEffect(() => {
  // это effect
  // этот код будет выполнен при монтировании компонента (componentDidMount)
  // а также после обновления любого элемента из массива зависимостей (componentDidUpdate)
  return () => {
  // это cleanup
	// этот код будет выполнен при размонтировании компонента (componentWillUnmount)
  // а также до обновления любого элемента из массива зависимостей (componentWillUpdate)
  }
}, [dep1, dep2]);
```
[Подробнее...](https://habr.com/ru/companies/otus/articles/668700/)



## useLayoutEffect

- подобен ***useEffect***, но срабатывает **синхронно** когда компоненты уже находятся на ***virtual dom*** (в памяти и можно прочитать/установить различные свойств), но еще не были отрисованы браузером

- позволяет вычислять параметры компонентов и изменять их до того, как браузер отрендерит их. Это предотвращает "мерцание" компонентов и улучшает производительность, потому что рендеринг происходит только 1 раз


## useContext

- позволяет получить доступ к контексту приложения

- контекст позволяет компоненту предоставлять некоторую информацию всему дереву под ним

- чтобы передать контекст необходимо:

    1. Создать и экспортировать его с помощью `export const MyContext = createContext(defaultValue)`
    2. Передать  его в хук `useContext(MyContext)`, чтобы прочитать его в любом дочернем компоненте, независимо от его глубины.
    3. Завернуть дочерние компоненты в `<MyContext.Provider value={...}>`, чтобы предоставить его от родителя.

- контекст проходит через любые компоненты в середине

- контекст позволяет писать компоненты, которые "адаптируются к своему окружению".

[Подробнее...](https://reactdev.ru/learn/passing-data-deeply-with-context/#_6)

## useReducer

 - предоставляет способ управления сложным локальным состоянием компонента через паттерн управления состоянием ***Reducer***

```js
const [state, dispatch] = useReducer(
    yourReducer,
    initialState
);

```
- обработчики событий компонента (onClick,onChange и т.п.) должны теперь только извещать редуктор о том, какое действие совершил пользователь:

```js
function handleOnClick(anyValue) {
  dispatch({
    //// action object, specific to component:
    type: 'what_happened',
    // other fields go here
    anyVar: anyValue
  });
};
```
- *action object* (объект действия) должен содержать минимальную информацию о том, что произошло

- он может иметь любую форму, принято задавать ему строку type, описывающую произошедшее, и передавать любую дополнительную информацию в других полях

- каждый объект действия должен описывать только одно взаимодействие пользователя, даже если оно приводит к нескольким изменениям данных

- **Reducer** (редуктор) принимает состояние на данный момент и действие, а возвращает следующее состояние


```jsx
function yourReducer(state, action) {
  switch (action.type) {
    case 'action1': {
      return state1;
    }
      case 'action2': {
        return state2;
    } 
    default: {
      throw Error('Unknown action: ' + action.type);
    }
  }
}
 ```
 
- редукторы работают во время рендеринга! (Действия ставятся в очередь до следующего рендера.) Это означает, что редукторы должны быть чистыми - одинаковые входы всегда приводят к одинаковому выходу. Они не должны посылать запросы, планировать таймауты или выполнять какие-либо побочные эффекты (операции, которые влияют на вещи за пределами компонента). Они должны обновлять объекты и массивы без мутаций

- для написания реукторов в мутирующем стиле можно использовать библиотеку *Immer*

[Подробнее...](https://reactdev.ru/learn/extracting-state-logic-into-a-reducer/#1)



## useRef

- позволяет создавать и управлять ссылками на DOM-элементы и другие объекты (идентификаторы таймаута, счетчики и пр.), 

- это синхронный хук, который немедленно обновляет состояние и сохраняет его значение на протяжении всего жизненного цикла компонента
 
- он не запускает повторный рендер компонента

- хук возвращает объект с единственным свойством *current*, содержащим текущее значение ссылки

- например, нажатие на кнопку фокусирует ввод, используя ссылку:

```jsx
import { useRef } from 'react';

export default function Form() {
    const inputRef = useRef(null);

    function handleClick() {
        inputRef.current.focus();
    }

    return (
        <>
            <input ref={inputRef} />
            <button onClick={handleClick}>
                Focus the input
            </button>
        </>
    );
}

```


## useMemo

 - оптимизирует производительность компонентов, предотвращая повторные вычисления

## useCalback

 - оптимизирует производительность компонентов, предотвращая ненужные перерисовки компонентов

 - использование useCallback выгодно только в случае передачи функции как props


```js
const Cars = ({ cars }) => {
  const onCarClick = useCallback((car) => {
    console.log(car.model);
  }, []);
  return cars.map((car) => {
    return (
      <Car key={car.id} car={car} onCarClick={onCarClick} />
    )
  });
}
```

  Таким образом все компоненты Car не будут рендериться лишний раз, т.к. ссылка на функцию останется прежней.


```js
const Car = ({ car, onCarClick }) => {
 const onClick = () => onCarClick(car);

  return (
    <button onClick={onClick}>{car.model}</button>
  )
}
```

  А вот здесь уже нет никакой пользы оборачивать метод в useCallback

  [Подробнее...](https://habr.com/ru/articles/529950/)


## useEffectOnce

- позволяет выполнить эффект только один раз после первого рендеринга компонента


## useDebugValue

- предоставляет дополнительную отладочную информацию для кастомных хуков

## useHistory, useLocation

- позволяют взаимодействовать с историей браузера и текущим URL внутри компонента

## useParams

- извлекает параметры из URL при использовании маршрутизации

## useForm

- помогает управлять состоянием форм и их валидацией

## useFetch

- предоставляет удобный способ выполнения HTTP-запросов

## useWindowSize

- отcлеживает изменения размеров окна браузера

## useId

- возвращает уникальный id, он сохраняется на протяжении всей жизни компонента

## useTransition

## useDeferredValue

## useSyncExternalStore

- предназначен для использования библиотеками, а не кодом приложения

## useInsertionEffect

- предназначен для использования библиотеками, а не кодом приложения

